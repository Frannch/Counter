<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Laberinto</title>
  <style>
    :root {
      --bg: #121212;
      --wall: #000;
      --floor: #f4f4f4;
      --player: #ff3fa4;
      --goal: #22d3ee;
    }
    html, body {
      height: 100%;
      margin: 0;
      background: var(--bg);
      display: grid;
      place-items: center;
      user-select: none;
      -webkit-user-select: none;
    }
    canvas {
      box-shadow: 0 16px 40px rgba(0,0,0,.6);
      border-radius: 10px;
      background: var(--floor);
    }
    .hint {
      position: fixed;
      bottom: 12px;
      color: #bbb;
      font: 14px system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
      opacity: .8;
    }
  </style>
</head>
<body>

  <canvas id="maze" width="588" height="588"></canvas>
  <div class="hint">Usa las flechas del teclado para moverte</div>
  <script>
  const GOAL_MESSAGE = "Felicitaciones Escapaste, La tercera letra es: P";

  const TILE = 28;
  const LEVELS = [
    { rows: 21, cols: 21 },
    { rows: 31, cols: 31 },
    { rows: 41, cols: 41 },
  ];

  let currentLevel = 0;
  let rows = LEVELS[currentLevel].rows;
  let cols = LEVELS[currentLevel].cols;

  function generateMaze(rows, cols) {
    const grid = Array.from({ length: rows }, () => Array(cols).fill('#'));
    function shuffle(arr) {
      for (let i = arr.length - 1; i > 0; i--) {
        const j = (Math.random() * (i + 1)) | 0;
        [arr[i], arr[j]] = [arr[j], arr[i]];
      }
      return arr;
    }
    function carve(r, c) {
      grid[r][c] = '.';
      const dirs = shuffle([[0, 2], [0, -2], [2, 0], [-2, 0]]);
      for (const [dr, dc] of dirs) {
        const nr = r + dr, nc = c + dc;
        if (nr > 0 && nc > 0 && nr < rows - 1 && nc < cols - 1 && grid[nr][nc] === '#') {
          grid[r + dr / 2][c + dc / 2] = '.';
          grid[nr][nc] = '.';
          carve(nr, nc);
        }
      }
    }
    carve(1, 1);
    grid[1][1] = 'S';
    grid[rows - 2][cols - 2] = 'G';
    return grid.map(row => row.join(''));
  }

  const canvas = document.getElementById("maze");
  const ctx = canvas.getContext("2d");

  let layout = [];
  let start = null, goal = null;

  const player = { r: 0, c: 0, radius: Math.floor(TILE * 0.28) };

  function color(varName, fallback) {
    return getComputedStyle(document.documentElement).getPropertyValue(varName) || fallback;
  }

  function setupLevel(index) {
    currentLevel = index;
    rows = LEVELS[currentLevel].rows;
    cols = LEVELS[currentLevel].cols;
    layout = generateMaze(rows, cols);
    canvas.width = cols * TILE;
    canvas.height = rows * TILE;

    start = null; goal = null;
    for (let r = 0; r < rows; r++) {
      for (let c = 0; c < cols; c++) {
        const ch = layout[r][c];
        if (ch === 'S') start = { r, c };
        if (ch === 'G') goal = { r, c };
      }
    }
    player.r = start.r;
    player.c = start.c;
    draw();
  }

  function draw() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    for (let r = 0; r < rows; r++) {
      for (let c = 0; c < cols; c++) {
        const x = c * TILE, y = r * TILE;
        const ch = layout[r][c];
        if (ch === '#') {
          ctx.fillStyle = color('--wall', '#000');
          ctx.fillRect(x, y, TILE, TILE);
        } else {
          ctx.fillStyle = color('--floor', '#f4f4f4');
          ctx.fillRect(x, y, TILE, TILE);
          if (ch === 'G') {
            ctx.fillStyle = color('--goal', '#22d3ee');
            const pad = 6;
            ctx.fillRect(x + pad, y + pad, TILE - pad * 2, TILE - pad * 2);
            ctx.strokeStyle = "#0ea5b7";
            ctx.lineWidth = 2;
            ctx.strokeRect(x + pad, y + pad, TILE - pad * 2, TILE - pad * 2);
          }
        }
      }
    }
    const px = player.c * TILE + TILE / 2;
    const py = player.r * TILE + TILE / 2;
    ctx.fillStyle = color('--player', '#ff3fa4');
    ctx.beginPath();
    ctx.arc(px, py, player.radius, 0, Math.PI * 2);
    ctx.fill();
  }

  function isWall(r, c) {
    if (r < 0 || c < 0 || r >= rows || c >= cols) return true;
    return layout[r][c] === '#';
  }

  function move(dr, dc) {
    const nr = player.r + dr;
    const nc = player.c + dc;
    if (!isWall(nr, nc)) {
      player.r = nr;
      player.c = nc;
      draw();
      if (nr === goal.r && nc === goal.c) {
        if (currentLevel < LEVELS.length - 1) {
          setupLevel(currentLevel + 1);
        } else {
          alert(GOAL_MESSAGE);
          setupLevel(0); // reinicia desde el primer nivel
        }
      }
    }
  }

  window.addEventListener('keydown', (e) => {
    const k = e.key;
    if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(k)) e.preventDefault();
    switch (k) {
      case 'ArrowUp':    move(-1,  0); break;
      case 'ArrowDown':  move( 1,  0); break;
      case 'ArrowLeft':  move( 0, -1); break;
      case 'ArrowRight': move( 0,  1); break;
    }
  }, { passive: false });

  // Si usas los botones .controls, siguen funcionando
  document.querySelectorAll('.controls button')?.forEach(btn => {
    btn.addEventListener('click', () => setupLevel(Number(btn.dataset.level)));
  });

  setupLevel(0);
  </script>
</body>
</html>