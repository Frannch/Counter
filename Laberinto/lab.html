<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Fran's Maze</title>
  <style>
    :root {
      --bg: #121212;
      --wall: #000;
      --floor: #f4f4f4;
      --player: #ff3fa4;
      --goal: #22d3ee;
    }
    html, body {
      height: 100%;
      margin: 0;
      background: var(--bg);
      display: grid;
      place-items: center;
      user-select: none;
      -webkit-user-select: none;
    }
    canvas {
      box-shadow: 0 16px 40px rgba(0,0,0,.6);
      border-radius: 10px;
      background: var(--floor);
    }
    .hint {
      position: fixed;
      bottom: 12px;
      color: #bbb;
      font: 14px system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
      opacity: .8;
    }
  </style>
</head>
<body>

  <canvas id="maze" width="588" height="588"></canvas>
  <div class="hint">Usa las flechas del teclado para moverte</div>
  <script>
  const GOAL_MESSAGE = "Felicitaciones Escapaste, La tercera letra es: P";

  // NUEVO: configuración de victoria → lobby
  const GAME_ID = 'laberinto';                 // Agrega este id en js/lobby.js para sumar la letra
  const LOBBY_PATH = '../html/lobby.html';     // Ruta al lobby
  const REDIRECT_DELAY = 10;                   // segundos

  // Cartel + cuenta regresiva y redirección al lobby
  function notifyWinAndRedirect(gameId, lobbyPath, seconds = 10) {
    try { localStorage.setItem(`win_${gameId}`, '1'); } catch (_) {}
    const target = `${lobbyPath}?win=${encodeURIComponent(gameId)}`;

    if (!document.getElementById('win-overlay-style')) {
      const style = document.createElement('style');
      style.id = 'win-overlay-style';
      style.textContent = `
        .win-overlay{position:fixed;inset:0;background:rgba(0,0,0,.75);display:flex;align-items:center;justify-content:center;z-index:99999}
        .win-box{background:#111;color:#fff;max-width:560px;width:90%;padding:24px;border-radius:14px;box-shadow:0 10px 30px rgba(0,0,0,.4);text-align:center;font-family:system-ui,Segoe UI,Roboto,Arial}
        .win-box h2{margin:0 0 8px;font-size:1.8rem}
        .win-box p{margin:6px 0}
        .win-actions{margin-top:14px;display:flex;gap:8px;justify-content:center}
        .win-btn{padding:.6rem 1rem;border-radius:8px;border:0;cursor:pointer;font-weight:700}
        .win-btn.primary{background:#22c55e;color:#111}
        .win-count{font-weight:800}
      `;
      document.head.appendChild(style);
    }

    const overlay = document.createElement('div');
    overlay.className = 'win-overlay';
    overlay.innerHTML = `
      <div class="win-box" role="dialog" aria-modal="true" aria-label="Has ganado">
        <h2>¡Felicitaciones!</h2>
        <p>Has escapado del laberinto.</p>
        <p>Volviendo al lobby en <span class="win-count" id="win-count">${seconds}</span> segundos…</p>
        <div class="win-actions">
          <button class="win-btn primary" id="win-go-now">Ir ahora</button>
        </div>
      </div>
    `;
    document.body.appendChild(overlay);

    function stopKeys(e){ e.stopImmediatePropagation(); }
    window.addEventListener('keydown', stopKeys, true);
    window.addEventListener('keyup', stopKeys, true);

    const countEl = overlay.querySelector('#win-count');
    const goNow = overlay.querySelector('#win-go-now');
    function go(){ window.location.href = target; }
    let left = seconds;
    const t = setInterval(() => {
      left -= 1;
      if (left <= 0) { clearInterval(t); go(); }
      else { countEl.textContent = String(left); }
    }, 1000);
    goNow.addEventListener('click', () => { clearInterval(t); go(); });
  }

  const TILE = 28;
  const LEVELS = [
    { rows: 21, cols: 21 },
    { rows: 31, cols: 31 },
    { rows: 41, cols: 41 },
  ];

  let currentLevel = 0;
  let rows = LEVELS[currentLevel].rows;
  let cols = LEVELS[currentLevel].cols;

  function generateMaze(rows, cols) {
    const grid = Array.from({ length: rows }, () => Array(cols).fill('#'));
    function shuffle(arr) {
      for (let i = arr.length - 1; i > 0; i--) {
        const j = (Math.random() * (i + 1)) | 0;
        [arr[i], arr[j]] = [arr[j], arr[i]];
      }
      return arr;
    }
    function carve(r, c) {
      grid[r][c] = '.';
      const dirs = shuffle([[0, 2], [0, -2], [2, 0], [-2, 0]]);
      for (const [dr, dc] of dirs) {
        const nr = r + dr, nc = c + dc;
        if (nr > 0 && nc > 0 && nr < rows - 1 && nc < cols - 1 && grid[nr][nc] === '#') {
          grid[r + dr / 2][c + dc / 2] = '.';
          grid[nr][nc] = '.';
          carve(nr, nc);
        }
      }
    }
    carve(1, 1);
    grid[1][1] = 'S';
    grid[rows - 2][cols - 2] = 'G';
    return grid.map(row => row.join(''));
  }

  const canvas = document.getElementById("maze");
  const ctx = canvas.getContext("2d");

  let layout = [];
  let start = null, goal = null;

  const player = { r: 0, c: 0, radius: Math.floor(TILE * 0.28) };

  function color(varName, fallback) {
    return getComputedStyle(document.documentElement).getPropertyValue(varName) || fallback;
  }

  function setupLevel(index) {
    currentLevel = index;
    rows = LEVELS[currentLevel].rows;
    cols = LEVELS[currentLevel].cols;
    layout = generateMaze(rows, cols);
    canvas.width = cols * TILE;
    canvas.height = rows * TILE;

    start = null; goal = null;
    for (let r = 0; r < rows; r++) {
      for (let c = 0; c < cols; c++) {
        const ch = layout[r][c];
        if (ch === 'S') start = { r, c };
        if (ch === 'G') goal = { r, c };
      }
    }
    player.r = start.r;
    player.c = start.c;
    draw();
  }

  function draw() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    for (let r = 0; r < rows; r++) {
      for (let c = 0; c < cols; c++) {
        const x = c * TILE, y = r * TILE;
        const ch = layout[r][c];
        if (ch === '#') {
          ctx.fillStyle = color('--wall', '#000');
          ctx.fillRect(x, y, TILE, TILE);
        } else {
          ctx.fillStyle = color('--floor', '#f4f4f4');
          ctx.fillRect(x, y, TILE, TILE);
          if (ch === 'G') {
            ctx.fillStyle = color('--goal', '#22d3ee');
            const pad = 6;
            ctx.fillRect(x + pad, y + pad, TILE - pad * 2, TILE - pad * 2);
            ctx.strokeStyle = "#0ea5b7";
            ctx.lineWidth = 2;
            ctx.strokeRect(x + pad, y + pad, TILE - pad * 2, TILE - pad * 2);
          }
        }
      }
    }
    const px = player.c * TILE + TILE / 2;
    const py = player.r * TILE + TILE / 2;
    ctx.fillStyle = color('--player', '#ff3fa4');
    ctx.beginPath();
    ctx.arc(px, py, player.radius, 0, Math.PI * 2);
    ctx.fill();
  }

  function isWall(r, c) {
    if (r < 0 || c < 0 || r >= rows || c >= cols) return true;
    return layout[r][c] === '#';
  }

  function move(dr, dc) {
    const nr = player.r + dr;
    const nc = player.c + dc;
    if (!isWall(nr, nc)) {
      player.r = nr;
      player.c = nc;
      draw();
      if (nr === goal.r && nc === goal.c) {
        if (currentLevel < LEVELS.length - 1) {
          setupLevel(currentLevel + 1);
        } else {
          // Antes: alert(GOAL_MESSAGE); setupLevel(0);
          // Ahora: mostrar cartel y regresar al lobby con ?win=laberinto
          notifyWinAndRedirect(GAME_ID, LOBBY_PATH, REDIRECT_DELAY);
        }
      }
    }
  }

  window.addEventListener('keydown', (e) => {
    const k = e.key;
    if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(k)) e.preventDefault();
    switch (k) {
      case 'ArrowUp':    move(-1,  0); break;
      case 'ArrowDown':  move( 1,  0); break;
      case 'ArrowLeft':  move( 0, -1); break;
      case 'ArrowRight': move( 0,  1); break;
    }
  }, { passive: false });

  // Si usas los botones .controls, siguen funcionando
  document.querySelectorAll('.controls button')?.forEach(btn => {
    btn.addEventListener('click', () => setupLevel(Number(btn.dataset.level)));
  });

  setupLevel(0);
  </script>
</body>
</html>